#!/bin/sh

. ../templates/template.subr


prepare_jail() {
	local name=$1
	local template=$2
	local path="$jail_base_path/$name"

	[ -d "$path" ] || {
		zfs list -t snap ${jail_pool}${jail_base_templates_path}/${template}@p0 > /dev/null || {
			echo "No template found, please prepare template ${jail_pool}${jail_base_templates_path}/${template}@p0 first, abort!"
			exit 1
		}
		zfs clone ${jail_pool}${jail_base_templates_path}/${template}@p0 ${jail_pool}${path} || {
			echo "Error prepare jail $name, abort!"
			exit 1
		}
		zfs snap ${jail_pool}${path}@p0
	}
}

clean_jail() {
	local name=$1
	local path="$jail_base_path/$name"

	[ -d "$path" ] && zfs destroy -r ${jail_pool}${path}
}

create_jail() {
	local name=$1
	local downlinks=$2
	local uplinks=$3
	local maxports=$4
	local path="$jail_base_path/$name"
	local exec_created="\"mount -t nullfs $PWD/conf/$name $path/usr/local/etc/frr\""
	local exec_start=""
	local vnet_interface=""

	local i=0
	for downlink in $downlinks
	do
		vnet_interface="$vnet_interface vnet.interface=\"${name}.${downlink}\""
		exec_start="$exec_start exec.start=\"ifconfig ${name}.${downlink} name en$i up\""
		i=$(($i+1))
	done

	local uplink_count=0
	for uplink in $uplinks
	do
		uplink_count=$(($uplink_count+1))
	done

	if [ $uplink_count -gt 0 ]; then
		local j=$(($maxports-$uplink_count))
		if [ $j -le $i ]; then
			echo "Current maxports [$maxports] is too small, please increase maxports, abort."
			exit 1
		fi

		for uplink in $uplinks
		do
			vnet_interface="$vnet_interface vnet.interface=\"${name}.${uplink}\""
			exec_start="$exec_start exec.start=\"ifconfig ${name}.${uplink} name en$j up\""
			j=$(($j+1))
		done
	fi

	exec_start="$exec_start exec.start=\"/bin/sh /etc/rc\""
	#jail -c name=$name path=$path exec.created=$exec_created host.hostname=$name mount.devfs vnet persist $vnet_interface $exec_start
	sh -c "jail -c name=$name path=$path exec.created=$exec_created host.hostname=$name mount.devfs vnet persist $vnet_interface $exec_start"
}

destroy_jail() {
	local name=$1
	local downlinks=$2
	local uplinks=$3
	local maxports=$4
	local path="$jail_base_path/$name"
	local exec_stop="/bin/sh /etc/rc.shutdown jail"

	jls -j $name > /dev/null 2>&1 && {
		jexec $name $exec_stop

		local i=0
		for downlink in $downlinks
		do
			jexec $name ifconfig en$i name ${name}.${downlink} down
			i=$(($i+1))
		done

		local uplink_count=0
		for uplink in $uplinks
		do
			uplink_count=$(($uplink_count+1))
		done
		if [ $uplink_count -gt 0 ]; then
			local j=$(($maxports-$uplink_count))
			for uplink in $uplinks
			do
				jexec $name ifconfig en$j name ${name}.${uplink} down
				j=$(($j+1))
			done
		fi

		jail -r $name
		umount -t nullfs $path/usr/local/etc/frr
		umount -t devfs $path/dev
	}
}


backup_jail() {
	local name="$1"
	local backup_path="$2"
	local jail_path="${jail_base_path}/${name}"
	local jl="${#jail_path}"
	jl=$((jl+1))

	if [ -z "$name" ]; then
		echo "Jail name required, abort!"
		exit 1
	fi
	if [ ! -d "$jail_path" ]; then
		echo "Jail $name does not exist, abort!"
		exit 1
	fi
	if [ -z "$backup_path" ]; then
		echo "Backup path required, abort!"
		exit 1
	fi
	if [ ! -e "$backup_path" ]; then
		echo "Backup path does not exist, try to create ${backup_path}"
		mkdir -p "$backup_path" || {
			echo "Error create ${backup_path}, abort!"
			exit 1
		}
	fi
	if [ ! -d "$backup_path" ]; then
		echo "Backup path $backup_path is not a directory, abort!"
		exit 1
	else
		if [ "$(ls -A $backup_path)" ]; then
			echo "Backup path $backup_path is not empty, abort!"
			exit 1
		fi
	fi

	zfs diff ${jail_pool}${jail_path}@p0 | {
		while IFS='	' read -r mode path
		do
			if [ "$mode" = "M" -o "$mode" = "+" ]; then
				if [ -f "$path" -o -L "$path" ]; then
					local basedir=$( dirname "$path" | cut -c "$jl"- )
					local basename=$( basename "$path" )
					if [ "$basename" = "DELETE_FILES" ]; then
						echo "Ambiguous file ${path}, abort!"
						exit 1;
					fi
					mkdir -p "${backup_path}${basedir}"
					cp -p "$path" "${backup_path}${basedir}"
				fi
			else
				if [ "$mode" = "-" ]; then
					path=$( echo "$path" | cut -c "$jl"- )
					echo "$path" >> "${backup_path}/DELETE_FILES"
				else
					echo "Unsupported mode $mode for $path, ignore"
				fi
			fi
		done
	}
}


restore_jail() {
	local name="$1"
	local backup_path="$2"
	local jail_path="${jail_base_path}/${name}"
	local bl="${#backup_path}"
	bl=$((bl+1))

	if [ -z "$name" ]; then
		echo "Jail name required, abort!"
		exit 1
	fi
	if [ ! -d "$jail_path" ]; then
		echo "Jail $name does not exist, abort!"
		exit 1
	fi
	if [ -z "$backup_path" ]; then
		echo "Backup path required, abort!"
		exit 1
	fi
	if [ ! -e "$backup_path" ]; then
		echo "Backup path does not exist, abort!"
		exit 1
	fi
	if [ ! -d "$backup_path" ]; then
		echo "Backup path $backup_path is not a directory, abort!"
		exit 1
	fi

	if [ -f "${backup_path}/DELETE_FILES" ]; then
		cat "${backup_path}/DELETE_FILES" | sort -r | {
			while IFS= read -r path
			do
				rm -d "${jail_path}${path}"
			done
		}
	fi
	find "$backup_path" -type f | {
		while IFS= read -r path
		do
			if [ "$path" = "${backup_path}/DELETE_FILES" ]; then
				continue;
			fi
			local basedir=$( dirname "$path" | cut -c "$bl"- )
			mkdir -p "${jail_path}${basedir}"
			cp -p "$path" "${jail_path}${basedir}"
		done
	}
}

